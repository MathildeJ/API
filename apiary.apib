yFORMAT: 1A
HOST: https://api.surfly.com/v2/

# Definition of terms

Throughout the API we refer to several terms specific to Surfly.  For clarification, 
these are defined below:

Client
 - A company that is a customer of Surfly 

Agent
 - An employee of the client company, who is available to help when the 'Start Session'
  button is pressed

User 
 - A generic term for either the agent, leader or follower.  Simply put,  a user is someone who 
 interacts with the Surfly application.  

Leader 
 - A leader initiates the session, and invites followers to join them.  They are normally in control of the session, but 
  can pass this control over to the follower.

Follower
 - Is invited to join the session by the leader.

UI
 - User Interface

iframe 
 - The implementation of Surfly.  

----

# The Co-Browsing API

Whilst Surfly can be used directly from the Surfly website, we also have an
extensive API.  This enables our clients to integrate Surfly tightly
into their current website or web application. You can even completely automate
the management of client and agent creation through our REST API.

The following types of customizations of Surfly can be achieved:

 - [Website Integration](#website_integration)
 - [Full Session Continuation](#full_session_continuation)
 - [Session Customization](#session_customization)
 - [Customize session start or join page](#custom_session_start)
 - [Application Integration](#application_integration)
 - [Agent Creation](#agent_creation)
 - [Reseller Automatization](#reseller_automatization)

For example code please see the [Reference Code](#reference_code) section below.

<a name="website_integration></a>
##### Website Integration

Add Surfly to your website and allow the visitors to your website to create a
support request by clicking on our support button.  The style and color of this
button can be fully customized to match your applications or website’s look and
feel. See the [support button appearance](#support_button) table for more information:

<a name="session_customization"></a>
##### Session Customization

Enable or disable the videochat, allow users to navigate to different websites
or not, use a textchat mode or a pure docked mode or, for our Enterprise
customers, completely remove all Surfly UI and fully customize the look and feel
of the session.

<a name="custom_session_start"></a>
##### Custom session start or join page

Start a session from your own website, or maybe even create a specific invite
page or landing page for your clients.

<a name="full_session_continuation"></a>
##### Full Session Continuation

When your users are already logged in on your website, you probably don’t want
a Surfly session breaking the flow and/or require them to login
again. Surfly can pick up the session exactly where the user is.

<a name="application_integration"></a>
##### Deep Application Integration

A session can be started through the Javascript and the REST API. By using the
REST API, you can integrate our websharing technology into your own application or
build a thin layer around our technology.

<a name="automatic_agent_creation"></a>
##### Automatic Agent Creation

Agents can be added through the admin interface, but, if your agents are more
dynamic, these can also be added and removed through our REST API.

<a name="reseller_automization"></a>
##### Reseller Automatization

Resellers can use our API to create new Surfly clients.  You decide whether you
want to invoice them directly or if we should handle this for you.


#### Adding customization

These type of customizations or integrations can be built in 3 different
ways, in order to manage the interface with Surfly:

 - The Surfly Code Snippet
 - The Javascript API
 - The REST API


----
#  The Surfly Code Snippet

Surfly's code snippet is a small snippet of Javascript code that can be copied
into your website template.

## The Surfly Widget and extension

Adding the Code Snippet is relatively straightforward. The snippet can be
obtained from the 'integration' page on your account settings panel.

Copy the code snippet and paste it into your website or applications source code.
We will make sure to load the Surfly code in an asynchronous
and non-blocking way so as not to have an effect on your page load times.


The snippet comes with lots of options which we will
detail in the [Session Interaction Options](#session_interaction_options) below:

### The chrome extension

If you do not want to immediately add the code to your website, but still want to
take a look at how Surfly's integration can work for you, use our Chrome extension. This
extension will add our Javascript snippet code to any website you are currently
browsing, it will also give you all the options to easily configure the snippet
and try out various settings.

In order to install the extension do the following:

 1. Download the Chrome Extension
 2. Open Chrome
 3. Go to  Tools / Preferences / Settings   (depends on your OS)
 4. Go to ‘Extensions’
 5. Click on ‘Load unpacked extension’
 6. Point it to the downloaded file


----
# Customizing Surfly Session Behavior

A variety of options are available for customizing Surfly. These can
be configured in the Javascript snippet, as an option in a REST call, or by simply
switching a flag in the Chrome extension.

<a name="session_interaction_options"></a>
## Session Interaction Options


|  Option | Default | Description |
| ---------------| ------------|------------|
| agent_can_request_control | false | The agent can request control, after which it can be granted by the controller |
| agent_can_take_control | false | The agent can take control without the requirement that the controller needs to grant it |
| agent_can_end_session | true | Show End Session button on follower's end |
| allow_original_file_download | false | Allow users to download shared files (when set to false, users can only view them) |
| blacklist | "[]" | (enterprise only) Restrict access to the specific resources. [More...](#restrictions)|
| enable_sounds | true | Enable sound notifications |
| filesharing | true | Allow file sharing |
| follower_redirect_url | false | After session end redirect the follower to a custom URL |
| format_session_id | true | Change the session id to something easy to communicate over the phone (eg, 123-123-123) |
| leader_redirect_url | false | After the session ends, redirect the leader to a custom URL |
| low_quality_video | false | Video quality is limited to 320x240@15 |
| newurl  | true | Should we show the 'newurl button' in the widget? |
| on_end_redirect_follower_to_queue | false | After session end return the follower to the Surfly Queue page |
| sharing_button | true | Should we show the 'sharing button' in the widget? |
| splash | true | Do we need to show the splash screen on session start? |
| start_muted | false | All participants start with muted microphone |
| store_chat_logs | false | If enabled, chat logs will be available for download in Surfly dashboard |
| videochat | true | Is videochat allowed? |
| whitelist | "[]" | (enterprise only) Allow access only to the specific resources. [More...](#restrictions)|

<a name="restrictions"></a>
#### Restrictions format
A string representation of the JSON array is expected. Every element of the array is an object with the following properties:
 - `pattern` - regular expression. The requested url will be matched to this regular expression
 - (optional) `redirect` - an url to redirect the user to. You can also specify the special `{{referer}}` pattern in the beginning of a redirect link, and that will be replaced by the Referer value at the moment of redirect. Basically, the user will be redirected to the page where they clicked the restricted link.
 - (optional) `type` - restriction type. If present, and set to `"all"`, restriction will be applied to all requests (otherwise restrictions affect only requests to top-level pages)

A blocked url is always added as a query parameter to the redirect url:
```
http://mysite.com/restricted?blocked_url=https%3A%2F%2Fexample.com
```

If a session was started with the Surfly button, and you want to end the session when a user requests a restricted page, redirect them to the page that includes `widget.js` and execute the following code:
```
Surfly.endSession(redirect_url);
```

`endSession` function will trigger the following events:
 - session continuation
 - end of the session
 - leader is redirected to the page specified in `redirect_url`

##### Blacklist example:
Restrict access to the website `example.com`. When the user tries to access `example.com` they will be redirected to the default page provided by Surfly

```
{
    "pattern": ".*example\\.com.*"
}
```

##### Whitelist example:
Allow access only to the `example.com`. When the user tries to access any other website they will be redirected to the provided redirect url

```
{
    "pattern": ".*example\\.com.*",
    "redirect": "https://example.com/restricted"
}
```

#### Session Appearance Options

|  Option | Default | Description |
| ---------------| ------------|------------|
| max_height | 0  | Restrict max height of the viewport |
| max_width | 0 | Restrict max width of the viewport |
| min_height | 0 | Restrict min height of the viewport |
| min_width | 0 | Restrict min width of the viewport |
| chat_box_color | #eb777f | Color of UI (chatbox) elements inside the session |
| dock_top_position | false | By default we place the dock at the bottom-left, with this option you can put it on top |
| docked_only | false | Only show the control options, do not show a video / textchat box |
| set_to_smallest | true | By default we resize the active viewport to viewport size of the participant with the smallest screen. This can be disabled |
| ui_off | false | Just co-browsing, no user interface (enterprise only) |
| white_label | false | Do not show a Surfly logo (enterprise only) |
| drawing_color | "default" | "Magic marker" color [see Drawing section below](#drawing_section) |
| drawing_mode | "temporary" | "Magic marker" mode [see Drawing section below](#drawing_section) |

<a name="drawing_section"></a>
##### Drawing

There are multiple ways to communicate within a Surfly session. One of them is
the drawing feature. This is enabled by default and allows users who are not
in control to highlight features on the page in the style of a "magic marker".
As can be seen from the session appearance options table above, there are 
two options used to change the drawing behavior: `drawing_mode` and
`drawing_color`. They can be set both as session options and via postMessage API
(see the [postMessage commands](#postMessage_commands) section).

As the `drawing_color` is set to the `"default"` value, this means that each user will
draw with their own color. You can set it to any color you like (specify a valid CSS
color string, e.g. `"blue"` or `"#0000ff"`). In this case all users will draw
with the same color.

The `drawing_mode` option can be set to one of the following values:
- "temporary" - drawings will fadeout automatically
- "permanent" - drawings will stay there until the next drawing_mode change	
- "disabled" - drawing functionality disabled

<a name="support_button"></a>
## Support Button Appearance

|  Option | Default | Description |
| ---------------| ------------|------------|
| auto_start | false | Instead of showing a button, immediately start a session |
| autohide_button | true | Hide the Surfly button when no agent is available |
| block_until_agent_joins | true | In case of the Surfly button, block the screen until a follower joins |
| end_of_session_popup_url | false | If this parameter is set, after session end the user will see a popup window with the contents from the specified URL |
| hide_until_agent_joins | true | In case of the Surfly button, do not show the cobrowsing window until a follower joins the session |
| hidden | false | Do not show the button |
| position | 'bottomleft' | Positions the Surfly Support Button. The options are: 'bottomleft', 'bottomright', 'middleright' |
| QUEUE_METADATA_CALLBACK | false |  A JS callback that can provide optional metadata (see queue customization section below) |
| QUEUE_ENDPOINT | false | Custom queue endpoint (see queue customization section below) |
| QUEUE_HANDLER | false | Custom JS queue handler (see queue customization section below) |
| QUEUE_CALLBACK | false | JS callback for queue monitoring (see queue customization section below) |
| stealth_mode | true | When enabled, users can use CTRL + ENTER to start a Surfly session |
| theme_font_background | surfly-red | The support button background color |
| theme_font_color | white | The support button foreground color|
| theme_font_size | 14 | The size of the text in the button |


## Field Masking

The business plan comes with the option to enable field-masking. This allows you to set a
special attribute on a FORM element called `surfly_private`. This will then prevent Surfly
from actually synchronizing the content of the field to followers. This can be useful for
sensitive fields such as creditcard numbers or social security numbers.

----

# Customizing the User Flow

The flexibility of Surfly allows it to be used with different types of usecases.
This allows you not only to customize how a Surfly session looks, but also how a
session can be integrated in your work flow.  Details on how to start a session can be 
found below.  


## Automatically starting a session


#### Using auto_start

If you want to allow your clients to start a session from a branded page you can
simply include our javascript snippet and set the 'auto_start' flag to true.


#### Using a special anchor link

Another way to start a session is to add the anchor '#surflystart' to any page
on which the Javascript snippet has been added. This can be used in various
ways, if you want to create a customized button that starts a session you can
simply put it within a "A" anchor. For example:

```html
<a href="#surflystart"> Start a surfly session </a>
```


## Detecting a Surfly Session

You might want to change the behaviour of the website depending on whether it is a
Surfly session or not. Example use cases are, for example, hiding a customized 'session
start' button within the Surfly session, or to remove certain toolbars for a more aesthetic 
integration.

#### From within Javascript

To detect a Surfly session from the client side, you can simply
check for the existence of a global variable called `__surfly`

For example, to hide a button within a Surfly session, you could implement the
following:

```javascript
if (window.__surfly) {
    document.getElementById('session_start_button').display = "none";
}

```


#### At the backend

As all Surfly sessions will originate from our proxy servers, this could be used
as a way to identify whether the request comes from Surfly or a client directly.
However, we use different IP ranges for our proxy servers, and they also change
over time, so we recommend a different way to do this.

On each session that comes through our proxy, we will add an 'X-Forwarded-For'
header that points to the original IP of the 'leader'.

When creating a request, you can also set the 'headers' option (in both the
Javascript call and the REST call) to add additional headers. These headers can
be used to, for example, add an "Authorization" header to allow to user to be logged
in on your own backend or a custom header which can be used as an identifier. We
will send these headers with each request made during the session.


## Session Continuation

The high performance of Surfly can be attributed to our proxy approach. If a
user wants to continue the web-session as-is, it is necessary to transfer
all information to our proxy.

This feature is called 'session continuation', and works as follows:

 - A Surfly session is started on the current website from the same url in a
   hidden iframe
 - The widget makes sure that Surfly knows about session variables (cookies)
 - After the session has been started we synchronize the current state with the
   fresh state loaded through the iframe
 - When Surfly finish is about to end, we transfer session data to the original
   page

Session continuation is currently supported only for sessions started with
Surfly widget.
There are several ways to set up session continuation.

### Full session continuation

This approach allows the transfer of all session data, including cookies with a `httpOnly`
flag. However, it requires some collaboration from the integrating website.
To make it work, the website needs to forward all HTTP requests for the path `/surfly_cookie_transfer/`
to the Surfly server. This is usually a small adjustment in load balancer configuration.
For example, if you use nginx, just add these lines in your config file:

```
location /surfly_cookie_transfer/ {
    proxy_pass https://surfly.com;
    proxy_set_header X-Continuation-Origin https://example.com;
    proxy_set_header X-Widget-Key 24d1414c71a94cbf9f205ed4fc4999b5;
}
```

In case of haproxy, see the example configuration below:

```
frontend example-com-https
  acl surfly_session_continuation hdr(host) -i example.com path_beg /surfly_cookie_transfer/
  use_backend surfly_continuation_point_https if surfly_session_continuation
  ...your custom configuration here...

backend surfly_continuation_point_https
    http-request set-header X-Continuation-Origin https://example.com
    http-request set-header X-Widget-Key 24d1414c71a94cbf9f205ed4fc4999b5
    http-request set-header Host surfly.com
    server surfly surfly.com:443 ssl
```

Please note that you also need to set additional request headers:
`X-Widget-Key` should contain your widget key (the same that is used in javscript snippet).
`X-Continuation-Origin` should contain the origin of the page where Surfly widget is integrated.
That is, a protocol scheme followed by domain name and a port in case it is non-standard.

After setting up the continuation point, add the following widget options:

```javascript
  cookie_transfer_enabled: true,
  cookie_transfer_proxying: true,
  cookie_transfer_urls: ["https://example.com/surfly_cookie_transfer/"]
```

### Soft session continuation

It is also possible to integrate session continuation without changing load
balancer configuration. All you need to do is to make sure that the Surfly widget
is present on all the pages you want to transfer cookies from (this is not necessarily
the same page where you start Surfly session from). However, soft session continuation
has some limitations:

- we will only transfer cookies from the current page
- for security reasons, a session will be transferred back only if the last page
  opened inside the session is on the same domain *and* has a Surfly widget on it
- since, in this case, Surfly doesn't have access to the HTTP requests, we *won't transfer
httpOnly cookies*

Make sure that you set the following options in your widget:
```javascript
  cookie_transfer_enabled: true,
  cookie_transfer_proxying: false
```

If you need more help with this, please contact us at support@surfly.com. We can
consult you on the implementation, or build the integration for you.


## Queue Behaviour Customization

It is possible to integrate Surfly into your website with a support
button. Once a user clicks this button, their support request will be queue'd
where one of the available agents can then answer the request. The user will be
the 'leader' of the session and the agent who joins will be the follower of the
session.

Surfly comes with a relatively straightforward dashboard. We not only allow you to enrich
the information presented on this dashboard but you can also completely build your own dashboard
and integrate it in your own web application.

Our Queue functionality works as follows:

  1. The user requests a session, through any of the provided options (button, #surflystart or Javascript call)
  2. We optionally enrich the Queue request by calling `QUEUE_METADATA_CALLBACK`, if set
  3. We call `QUEUE_HANDLER` with a *callback* and a *JSON Request Object* containing (enriched) session information.
    - Our own `QUEUE_HANDLER` will make a REST call to `QUEUE_ENDPOINT` with this *JSON object*
    - Once the QUEUE was succesfully called, `QUEUE_HANDLER` should call the provided *callback* with the status and
       a *JSON Response Object*
  4. On any further Queue status change we call `QUEUE_CALLBACK` with this *JSON Session Object*


#### Set a custom Queue Endpoint

You can configure the 'QUEUE_ENDPOINT' in the Javascript snippet to specify where
we should fire a request each time a new user wants to start a session.


##### JSON Request Format

As long as an agent is Queue'd, we will fire a POST request to this endpoint
containing the following JSON in the request body:


```
{
    "url": <actual url to start a session on>,
    "id": <session_id>,
    "viewer_link": <the link the agent needs to open to join the session>,
    "ip_address": <ip address of the website visitor>
}
```

Your controller that handles this request can then display or dispatch the
viewer link to any of the available agents.

##### JSON Response Format

The endpoint is expected to respond with a JSON object. It must contain at least one
field - `identifier`, which should be a unique string identifying the current session:

```
{
    "identifier": "<unique_id>",
    ...additional session metadata from server side...
}
```

We will pass the endpoint response to `QUEUE_CALLBACK` every time (see below), so you can
store session metadata in additional fields.


#### Set up custom Javascript Queue Handler

If you want to completely handle the Queue functionality yourself, you can also
provide us with a custom Javascript function object as a `QUEUE_HANDLER` option.

If it is specified, we will call `QUEUE_HANDLER` when a user requests a Surfly
session (instead of making an AJAX call to `QUEUE_ENDPOINT`). `QUEUE_HANDLER`
will be given two arguments:

- A JSON object with session information (see *JSON Request Format* for `QUEUE_ENDPOINT` above)
- A success callback function, `QUEUE_HANDLER`, must call this callback after a successful
  queue join. You must pass a session metadata object as a first argument (see *JSON
  Response Format* for `QUEUE_ENDPOINT` above)


#### Enriching a Queue request with Metadata

Prior to making the call to `QUEUE_HANDLER`, we will call `QUEUE_METADATA_CALLBACK`, which can enrich
the Queue request with additional METADATA from the client side. For example, if you have the widget
added to a section of your web application where the user is required to be logged in, you probably
have some knowledge about the user which might be useful to pass along to the agent. Information such
as the users' name, email or even their phonenumber.

To make sure that this information becomes available in the dashboard you can set `QUEUE_METADATA_CALLBACK`
to a special function that will return an object that provides these values as key, value pairs. For example:

```
{
    "name": "John Doe",
    "email": "john.doe@example.com",
    "phone": "+123123123123"
}
```

Of these key,value pairs, `name` and `email` will also be provided to the Surfly session so that the session can display the
name of the user in the chatbox and make sure that the accompanying gravatar matches his email address.



#### Tracking queue status

You can also provide a Javascript function in the `QUEUE_CALLBACK` option to trace the status of the queue on the client side.
We will call this function every time a user is being queue'd, rejoins, or leaves the queue.

It will be called with two arguments:

 - status (true or false)
   - true   (on successful join or rejoin)
   - false  (after cancel, close)
 - session - a *JSON Response object* describing the session (this is received from `QUEUE_HANDLER` or `QUEUE_ENDPOINT`)

----

# Customize the Session Interface

After the iframe has been created, it can be controlled via postMessage and
will emit messages back to the parent frame. You can start a Surfly session with
the UI=OFF flag as described above.

## Events

The messages sent by Surfly iframes to the parent window are JSON-encoded strings that have the following format:

```json
{"surfly":
  {
    "type": "<event type>"
    "params": {<additional parameters depending on event type}
  }
}
```

<!-- "client_id": <from query string> -->


### The location of the top iframe has changed

 - type: `"relocated"`
 - params: `{"url": <absolute URL of new location>, "how": <how>}`

 how is `"load"` if the page was loaded, or `"history"` if the URL was changed through history API.

### Another viewer joined

 - type: `"viewer_joined"`
 - params: `{"count": <the updated total number of viewers>}`

<!-- params: {"client_id": <client_id of the new participant TODO> -->


### A viewer has left

 - type: `"viewer_left"`
 - params: `{"count": <the updated total number of viewers>}`

<!-- params: {"client_id": <client_id of the new participant TODO> -->

### Session was finished

 - type: `"session_ended"`
 - params: `{"reason": "<one of the following>"}`
  - `"leader_ended"`     leader ended the session via end the session command
  - `"leader_left"`      leader closed the browser
  - `"leader_timeout"`   leader connection timed out
  - `"api"`              session was ended via HTTP API


### Error

 This event is sent if the session cannot be joined and has ended abuptly.

 - type: "error"
 - params: `{"reason": <one of the following>}`
  - `"other_connection"` happens on if the leader_link was opened elsewhere. The new window/browser becomes the leader and the old leader is kicked out. It also happens if viewer_link was open again on the same browser.
  - `"connect_failed"` happens if WebSocket connection to Surfly cannot be established.

<!--
  - "SESSION_NOT_FOUND"
  - "BROWSER_NOT_SUPPORTED"
-->


### Message

 - type: `"message"`
 - params: `{"data": "<data>"}`

### Control over session was transferred to another party

 - type `"control"`
 - params:
  - `"to"`: index of the client that now have the control. Always 0 for the leader, 1 or more for a viewer.
  - `"gained"`: if true, the control was just gained; if false, the control was just lost


## Usage example

In the following example we are using a JS API to show a popup window every time
a cobrowsing session is finished (similar functionality can be achieved by
using `end_of_session_popup_url` option, but here we have full control over popup
rendering).

```javascript
// put your custom page address here
var popupUrl = '//example.com';
// surflyOrigin can be different if you are using on-premise solution
var surflyOrigin = 'https://surfly.com';
window.addEventListener("message", function(e){
  if (e.origin === surflyOrigin) {
    var data = JSON.parse(e.data);
    if (data.surfly.type === 'session_ended') {
      var popup = document.createElement('iframe');
      popup.style.cssText = "display:block;position:fixed;height:80%;width:80%;top:10%;left:10%;z-index:99999;background-color:white;";
      popup.src = popupUrl;
      document.body.appendChild(popup);
    }
  } else {
    console.log(e);
  }
}, false);
```


## Commands

Commands are sent by calling postMessage on the Surfly iframe. The message should be a JSON-encoded object. Currently only the leader frame accepts the command.

### Relocate

```
{"command": "relocate", "url": "<new url to go to>"}
```

### End the session

```
{"command": "end"}
```

### Send a message to other parties

```
{"command": "message", "data": "<data>"}
```

This will broadcast string `"<data>"` to all other parties in the session.


### Change controlling party

```
{"command": "control", "to": <client index>}
```

`<client index>` is 0 for leader and 1 or more for viewers.

This will put the session leader into viewer mode and the selected follower will become the pilot of the session. The following actions can now be done by follower:

 - scrolling
 - clicking
 - entering data in forms

If the same code is ran by the follower currently holding control, it will return control back to leader.


<a name="postMessage_commands"></a>
### Change the drawing settings (only on leader side)

```
{"command": "drawing_settings", "settings": {"mode": "<drawing_mode>", "color": "<drawing_color>"}}
```

Valid values are discussed in the [Drawing section](#drawing_section). Note that one of "mode" and "color" keys may be omitted

----
# REST API

The Surfly REST API allows you to integrate the functionality of our dashboard in a programatical manner. With our API you can do the following things:

 * Clients - Create new clients *(reseller only)*
 * Agents - Manage your agents
 * Sessions - Get an overview of all your session
 * Queue - Manipulate the incoming Queue for your agents

To access our API, you will need to authenticate by using basic HTTP authentication.  In addition, some API calls require extra information such as:

 * RESELLER_KEY  *(reseller only)*
 * CLIENT_KEY

Both keys can be found on your API page in your dashboard. We recommend that you keep your CLIENT_KEY and RESELLER_KEY secret at all times.


<a name="reference_code"></a>

########################################
# Group Agents


# Agents Collection [/agents/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### List all agents [GET]


+ Response 200 (application/json)

        [
            {
                "agent_id": 1,
                "agent_name": "Peter Pan",
                "agent_email": "peter@neverland.net"
            }
        ]

### Create a new agent [POST]


+ Request (application/json)

        {
            "username": "Peter Pan",
            "agent_email": "peter@neverland.net",
            "password":"Pass@123"
        }

+ Response 200 (application/json)

        {
            "agent_id": "1"
        }



# Agent information [/agents/{AGENT_ID}/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)
    + AGENT_ID (string, `2`)

### Get Agent Information [GET]


+ Response 200 (application/json)

        {
            "agent_id": 2,
            "agent_name": "John Doe",
            "agent_email": "john.doe@example.com"
        }


### Update an agent [PUT]

+ Request (application/json)

        {
            "username": "Peter",
            "agent_email": "peter@neverland.com"
        }

+ Response 200 (application/json)

        {
            "agent_name": "Peter",
            "agent_id": 2,
            "agent_email": "peter@neverland.com"
        }

### Delete an agent [DELETE]


+ Response 200 (application/json)

        {
            "response": "Agent has been removed successfully"
        }





########################################
# Group Sessions


# Sessions Collection [/sessions/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### List all Sessions [GET]


+ Response 200 (application/json)

        [{
            "session_id": "fOBg4dXAPTHSoil6LywgfYA",
            "agent_id": "fOBg4dXAPTHSoil6LywgfYA",
            "viewer_link": "https://session.surfly.com/fwqcOuuMwTty7ii3kcA8Q",
            "start_time": "Fri, 10 okt 10:20 AM",
            "duration": 123
        }]

### Create a session [POST]


+ Request (application/json)

        {
            "url": "http://www.surfly.com/"
        }

+ Response 200 (application/json)

        {
            "id": "fm6pApJ18SvqlVEpnCx8Qmg",
            "agent_id": "jGBAOLFaRv6NG57AZubK8A",
            "viewer_link": "https://session.surfly.com/fm6pApJ18SvqlVEpnCx8Qmg",
            "start_time": "2014-12-11T15:12:22.447Z",
            "end_time": null,
            "duration": null,
            "ip_leader": "127.0.0.1",
            "leader_link": "https://session.surfly.com/mUBRJyslQStVXPEwUwFyQ",
            "ip_follower": "127.0.0.1",
            "emails_send": [
            {
              "to": [],
              "from": null
            }
            ]
        }



# Active Sessions Collection [/sessions/?api_key={API_KEY}&active_session=true]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### List all Active Sessions [GET]


+ Response 200 (application/json)

        [{
            "session_id": "fOBg4dXAPTHSoil6LywgfYA",
            "agent_id": "fOBg4dXAPTHSoil6LywgfYA",
            "viewer_link": "https://session.surfly.com/fwqcOuuMwTty7ii3kcA8Q",
            "start_time": "Fri, 10 okt 10:20 AM",
            "duration": 123
        }]

# Agent Sessions Collection [/sessions/?api_key={API_KEY}&active_session=true&agent_id=1&year=2015&month=01]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### List Active Sessions for Agent [GET]


+ Response 200 (application/json)

        [{
            "session_id": "fOBg4dXAPTHSoil6LywgfYA",
            "agent_id": "fOBg4dXAPTHSoil6LywgfYA",
            "viewer_link": "https://session.surfly.com/fwqcOuuMwTty7ii3kcA8Q",
            "start_time": "Fri, 10 okt 10:20 AM",
            "duration": 123
        }]




# Session Information [/sessions/{SESSION_ID}/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)
    + SESSION_ID (string, `fuSHr0sRQ1usugvheahwQ`)


### Get session information [GET]


+ Response 200 (application/json)

        {
            "id": "fwqcOuuMwTty7ii3kcA8Q",
            "agent_id": 1,
            "viewer_link": "https://session.surfly.com/fwqcOuuMwTty7ii3kcA8Q",
            "start_time": "Fri, 10 okt 2014 10:20:24",
            "end_time": "Fri, 10 okt 2014 10:51:46",
            "duration": 1882,
            "ip_leader": "192.168.1.1",
            "leader_link": "",
            "ip_follower": "",
            "emails_send": [
                                {
                                    "to": [],
                                    "from": null
                                }
                            ]
        }


### End a session [DELETE]


+ Response 200 (application/json)

        {
            "response":""
        }








########################################
# Group Queue


# Queue Collection [/queue/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### List all Active Sessions in the Queue [GET]


+ Response 200 (application/json)

        [
            {
                "start_time": 1,
                "session": 1,
                "url": ""
            }
        ]

### Add an item to the Queue [POST]


+ Request (application/json)

        {
            "url": "http://www.example.com/",
            "id": "fuSHr0sRQ1usugvheahwQ"
        }

+ Response 200 (application/json)

        {
            "start_time": "",
            "session": 1,
            "url": ""
        }


# Queue information [/queue/{QUEUE_ID}/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)
    + QUEUE_ID (string, `fuSHr0sRQ1usugvheahwQ`)

### Get Queue Information [GET]


+ Response 200 (application/json)

        {
            "start_time": "2014-11-03T08:22:41.075Z",
            "session": "fuSHr0sRQ1usugvheahwQ",
            "url": "http://example.com/"
        }


### Remove item from the Queue [DELETE]


+ Request (application/json)

        {
            "id": "fuSHr0sRQ1usugvheahwQ"
        }

+ Response 200 (application/json)

        {
            "detail":""
        }



########################################
# Group Clients

# Clients Collection [/clients/{RESELLER_KEY}/?api_key={API_KEY}]

+ Parameters
    + RESELLER_KEY (string, `02fbfd63b54341c1828e6a2426311788`)
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### Lists all your clients [GET]

+ Response 200 (application/json)


        [{
            "company_name": "Neverland",
            "client_key": "AOEUaoeuntsPDe",
            "agent_count": 15,
            "widget_key": "24d1414c71a94cbf9f205ed4fc4999b5",
            "rest_key": "3b57bd2db21c46d2875508b982968d26",
            "domains": "example.com, *.example.com"
        }]

### Create a new client [POST]


+ Request (application/json)

        {
            "company_name": "Test User"
        }

+ Response 200 (application/json)

        {
            "company_name": "Neverland",
            "client_key": "fOBg4dXAPTHSoil6LywgfYA"
        }

# Client Information [/clients/{RESELLER_KEY}/{CLIENT_ID}/?api_key={API_KEY}]

+ Parameters
    + RESELLER_KEY (string, `02fbfd63b54341c1828e6a2426311788`)
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)
    + CLIENT_ID (string, `63668234b4aa19dd436e6a76ab8ae000`)

### Get Client Information [GET]

+ Response 200 (application/json)

        {
            "company_name": "Neverland",
            "client_key": "AOEUaoeuntsPDe",
            "agent_count": 15,
            "widget_key": "24d1414c71a94cbf9f205ed4fc4999b5",
            "rest_key": "3b57bd2db21c46d2875508b982968d26",
            "domains": "example.com, *.example.com"
        }

### Set Client Domain List [POST]

+ Request (application/json)

        {
            "domains": "example.com, *.example.com"
        }

+ Response 200 (application/json)

        {
            "domains": "example.com, *.example.com"
        }

### Update a client [PUT]


+ Request (application/json)

        {
            "company_name": "Peter Pan"
        }

+ Response 200 (application/json)

        {
            "company_name": "Peter Pan"
        }

### Delete the Client [DELETE]

+ Response 200 (application/json)

        {
            "response":"Client has been removed Successfully"
        }





# Reseller Sessions Collection [/sessions/?api_key={API_KEY}&clientkey={CLIENT_KEY}&active_session=true&year=2015&month=01]

+ Parameters
    + CLIENT_KEY (string, `00063668234b4aa19dd436e6a76ab8ae`)
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)


### Example: List Active Sessions for Reseller's Client [GET]


+ Response 200 (application/json)

        [{
            "session_id": "fOBg4dXAPTHSoil6LywgfYA",
            "agent_id": "fOBg4dXAPTHSoil6LywgfYA",
            "viewer_link": "https://session.surfly.com/fwqcOuuMwTty7ii3kcA8Q",
            "start_time": "Fri, 10 okt 10:20 AM",
            "duration": 123
        }]



########################################
# Group Invoice


# Invoice Collection [/get/invoice/details/?api_key={API_KEY}]

+ Parameters
    + API_KEY (string, `3b57bd2db21c46d2875508b982968d26`)

### Lists your current month's invoice [GET]

+ Response 200 (application/json)

        [{
            "item_list": [{
                "amount": 40,
                "description": "Date from 2015-06-29 to 2015-01-29",
                "unit_price": 0.67,
                "quantity": 60
            }],
            "issue_date": "2015-6-06",
            "to_address": "ABC,1221,Netherlands,4343",
            "from_address": "Surfly Admin, Netherlands",
            "payment_term": 14,
            "sub_total": 1490,
            "currency": "euro",
            "invoice_number": 5,
            "total": 1490
        }]
